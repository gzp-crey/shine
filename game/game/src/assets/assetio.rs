use crate::assets::io::{AssetLowIO, HashableContent};
use crate::assets::{AssetError, Url};

pub struct AssetIO(AssetLowIO);

impl AssetIO {
    pub fn new() -> Result<AssetIO, AssetError> {
        Ok(AssetIO(AssetLowIO::new()?))
    }

    pub async fn download_binary(&self, url: &Url) -> Result<Vec<u8>, AssetError> {
        self.0.download_binary(url).await
    }

    pub async fn download_string(&self, url: &Url) -> Result<String, AssetError> {
        String::from_utf8(self.0.download_binary(url).await?)
            .map_err(|err| AssetError::ContentLoad(format!("Failed to parse response for {}: {}", url.as_str(), err)))
    }

    pub async fn upload_binary(&self, url: &Url, data: &[u8]) -> Result<(), AssetError> {
        self.0.upload_binary(url, data).await
    }

    pub async fn upload_string(&self, url: &Url, data: &str) -> Result<(), AssetError> {
        self.0.upload_binary(url, data.as_bytes()).await
    }

    /// Upload a binary data based on the path generated by the hash of the content
    pub async fn upload_cooked_binary(
        &self,
        target_base: &Url,
        ext: &str,
        content: &[u8],
    ) -> Result<String, AssetError> {
        let hashed_path = content.hashed_path();
        let target_file = format!("{}.{}", hashed_path, ext);
        let target_url = target_base.join(&target_file)?;

        self.0.upload_binary(&target_url, &content).await?;

        Ok(target_file)
    }
}
